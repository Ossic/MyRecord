# 理解inode

inode 是指在许多“类 Unix **文件系统**”中的一种数据结构。每个 inode 保存了文件系统中的一个**文件系统对象**（包括文件、目录、设备文件、socket、管道, 等等）的**元信息数据**，但不包括数据内容或者文件名。

用心去体会 Unix 设计哲学吧！ 2333

## inode是什么

理解 inode，要从文件储存说起。

文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存 512 字节，相当于0.5KB（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是 4096 字节）。~~还记得曾经发过一篇 4K 对齐的文章么？？~~

操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。
一个块大小 = `一个扇区大小 * 2 ^ n` ,这个 n 可以是任意的，但是块小了效率低，大了又浪费空间，因为文件系统的最小单位是块，比如一个数据大小是3个块还多出1字节，那么这1字节也要用一个块 (4K) 存，并且是只能存这1字节；目前一般都是采用 4K

文件**数据**都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的**元信息**，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做 inode，中文译名为"索引节点"。

每一个文件都有对应的 inode，里面包含了与该文件有关的一些信息。

可以用 `stat` 命令，查看某个文件的 inode 信息：`stat example.txt`
总之，除了文件名以外的所有**文件信息**，都存在 inode 之中。注意，是文件信息不是文件内容(数据)
inode 与文件数据是生死相依、一损俱损的关系，生命周期一致。

## inode的大小

inode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是 inode 区（inode table），存放 inode 所包含的信息。

每个 inode 节点的大小，一般是 128 字节或 256 字节（这个数值可以在格式化的时候设定）。inode 节点的总数，在格式化时就给定，一般是每 1KB 或每 2KB 就设置一个 inode。
假定在一块 1GB 的硬盘中，每个 inode 节点的大小为128 字节，每 1KB 就设置一个 inode，那么 inode table 的大小就会达到 128MB，占整块硬盘的 12.8%。不过在典型的实现下，所有 inode 占用了文件系统 1% 左右的存储容量。

查看每个 inode 节点的大小，可以用如下命令：

>   sudo dumpe2fs -h /dev/hda | grep "Inode size"

查看使用情况：`df -iH`

由于每个文件都必须有一个 inode，因此如果硬盘有太多的零碎小文件，有可能 inode 已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。

至于数据区和 inode 区到底是如何划分的和文件系统有关，比如 Linux 常用的是 ext4 文件系统，展开说又是一大篇，以后有机会再说！

>   使用 mkfs 进行格式化的时候可以：
>   `-i 2048` ：更改 inode 每 2KB 创建一个
>   `-I 128 `：指定 inode 大小
>   `-b 8192` ：设置 block size 的大小为8kB
>   `-f 1024 `：设置 fragments 的大小为1KB

## inode的号码

每个 inode 都有一个号码，操作系统用 inode 号码来识别不同的文件。

这里值得重复一遍，**Unix/Linux 系统内部不使用文件名，而使用 inode 号码来识别文件**。对于系统来说，文件名只是 inode 号码便于识别的别称或者绰号。

表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：

-   首先，系统找到这个文件名对应的 inode 号码；
-   其次，通过 inode 号码，获取 inode 信息；
-   最后，根据 inode 信息，找到文件数据所在的 block，读出数据。

使用 `ls -i` 命令，可以看到文件名对应的 inode 号码

## 目录文件

Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。

每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。ls 命令只列出目录文件中的所有文件名

理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和 inode 号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在 inode 节点中，而读取 inode 节点内的信息需要目录文件的执行权限（x）。

另外，只要有访问权限，你就可以随意访问这些目录下的文件，但是只有内核的进程能够修改它们，比如你用 vim 打开一个目录：

```tex
" Press ? for help

.. (up a dir)
/home/chjq/app/
▸lnmp0.9-full/
  latest.tar.gz
  lnmp0.9-full.tar.gz
  wordpress-3.5.1-zh_CN.tar.gz
```

其中，`“▸”` 表示子目录，把光标移动到 `“▸”`，通过快捷键 “o” 还可以展开或收起该子目录下的内容。选中某个文件回车还能直接在 vim 中打开。

当然，这些操作只能在命令行里进行，如果你一定要在图形界面下打开一个文本编辑器，然后愣把文件夹往里拽，操作系统就只能跟你说“臣妾我做不到啊！”

在这顺便给大家介绍两个命令，如果你想知道某个文件夹下包含了几个文件，可以这样：

```shell
find ./app -type f | wc -l
```

如果你想统计该文件夹下的文件大小，可以这样：

```shell
du -sh app/
```

## 二逼文件

这里介绍的文件类型平时操作很少用到，我把它们统称为二逼文件类型，光荣入选的有以下几个。

-   **块设备文件和字符设备文件**，这些文件一般隐藏在 `/dev` 目录下，昼伏夜出，平时你感觉不到它们的存在，但是你想进行设备读取和外设交互时，就是它们大显身手的时候。比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件。系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外。
-   **FIFO**，江湖人称命名管道，主要用于进程间通讯。比如使用 mkfifo 命令可以创建一个 FIFO 文件，启用一个进程 A 从 FIFO 文件里读数据，启动进程 B 往 FIFO 里写数据，先进先出，随写随读，童叟无欺。
-   **套接字（socket）**，也是一种文件类型，可以用于进程间的网络通信，也可以用于本机之间的非网络通信。比如你会时不时见到后缀为 sock 的进程文件，这些文件一般隐藏在 `/var/run` 目录下，它们活跃在服务器里，证明着那些相关进程的存在。
-   **符号链接（symbolic link）**，这种类型的文件类似 Windows 中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接。

## 硬连接与软连接

一般情况下，文件名和 inode 号码是"一一对应"关系，每个 inode 号码对应一个文件名。但是，Unix/Linux 系统允许，**多个文件名指向同一个 inode 号码。**
这其实就是硬连接，修改任何一个其他也随之变化，因为指向都是相同的

inode 信息中有一项叫做"链接数"，记录指向该 inode 的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得 inode 节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个 inode，系统就会回收这个 inode 号码，以及其所对应 block 区域。

>   创建目录时，默认会生成两个目录项：`"."` 和 `".."`。前者的 inode 号码就是当前目录的 inode 号码，等同于当前目录的"硬链接"；
>
>   后者的 inode 号码就是当前目录的父目录的 inode 号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）。

硬链接不创建 inode，所以无法跨文件系统，这一点可以由软链接实现。

---

这样软连接也就好说了，比如 A 是 B 的一个软连接，A、B 的 inode 不相同，A 中其实保存的是 B 的路径，所以也就是说 A 是依赖于 B 的，如果把 B 删了，A 就会报错，找不到文件，软链接创建的时候加 -s 参数：`ln -s`

## 特有技能

由于 inode 号码与文件名分离，这种机制导致了一些 Unix/Linux 系统特有的现象。

  　　1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除 inode 节点，就能起到删除文件的作用。

  　　2. 移动文件或重命名文件，只是改变文件名，不影响 inode 号码。说白了，文件名就是一个别名、属性而已

  　　3. 打开一个文件以后，系统就以 inode 号码来识别这个文件，**不再考虑文件名**。因此，通常来说，系统无法从 inode 号码得知文件名。

第3点使得软件更新变得简单，**可以在不关闭软件的情况下进行更新**，不需要重启。因为系统通过 inode 号码，识别运行中的文件，不通过文件名。
更新的时候，新版文件以同样的文件名，生成一个新的 inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的 inode 则被回收。

这样处理最直观的好处就是，你可以对正在使用的文件改名，换目录，甚至放到废纸篓，都不会影响当前文件的使用，这在 Windows 里是无法想象的。

## 参考

http://www.epubit.com.cn/book/onlinechapter/12331
http://www.ruanyifeng.com/blog/2011/12/inode.html
https://zh.wikipedia.org/wiki/Inode