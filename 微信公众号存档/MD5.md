# MD5

> 本文介绍了关于MD5的一些基础概念，没有什么难度，至于其中的一些名词可以先跳过，知道什么作用就行，~~以后会详细解释的~~
> 以及java的实现...封装的真是太好了！~~不用动脑子了~~

## 了解MD5

MD5的应用非常广泛。例如我们在下载文件时，有时会提供文件的MD5值，因此当我们得到这个文件后，使用工具计算该文件对应的md5值，然后和网站给出的值进行对比，如果不一致，就可以得知文件内容发生了变化。
MD5在密码加密方面也应用广泛

### 那么MD5到底是什么？

message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它：信息→**摘要**算法。
MD5**算法**将整个文件当作一个大文本信息，通过其**不可逆**的字符串变换算法，产生了这个**唯一的**MD5信息**摘要**。这就相当于这个文件的指纹，如果有任何人修改了文件内容，或下载文件由于网络问题不完整，则生成的md5值也会发生变化。
**MD5算法本质是一个哈希算法，因此MD5值就是一个哈希值。**
所以我们就可以得知MD5的一些特点：

1. 对于同样的文件，计算出的MD5值永远是一样的。**MD5算法中没有任何随机数或不确定因素。**
2. MD5算法是公开的。因而我们可以找到很多个MD5生成器，但背后的算法是一样的。
3. 我们可以认为世界上的文件是无限的，而得到的MD5值永远是一个128位二进制数。**因此是一个无穷序列到一个有限序列的映射。进而可以得知，MD5算法是不可逆的，也就是说，我们不能用一个MD5值来推算出源文件的内容。**
4. 从无穷序列到有限序列的映射这点又可以推断出，MD5算法可能产生冲突(这也是所有哈希函数都会遇到的问题)。**即两个不同的文件，可能会产生一样的MD5值。**我们知道2^128次方是个巨大无比的数字，因此之前认为MD5的冲突在理论上存在，**现实生活中遇到的可能性很低，因此是个可靠的算法**。然而近年研究出的碰撞算法使得计算机在很短的时间内就可以得出一个可能的冲突值，这就是MD5算法的缺陷。

### 误区:摘要和加密

**加密**后的消息是完整的；**具有解密算法，能得到原始数据**；
**摘要**得到的消息是不完整的；通过摘要的数据，**不能得到原始数据**；
所以，当看到很多人说，md5，加密，解密的时候，呵呵一笑就好了。
这就是上面强调摘要的原因

### MD5的长度

有人说md5,`128位`，`32位`，`16位`，到底md5多长？
md5的长度，**默认为128bit**，也就是128个0和1的二进制串。
这样表达是很不友好的。
所以将二进制转成了16进制，**每4个bit表示一个16进制**，
所以128/4 = 32 换成16进制表示后，**为32位了**。
但是呢，我们经常能看到16位的MD5，这是什么鬼，先来看下区别：

> md5(admin,32) = 21232f297a5**7a5a743894a0e**4a801fc3
>
> md5(admin,16) = 7a57a5a743894a0e

很明显了！
其实16位的长度，是从32位md5值来的。**是将32位md5去掉前八位，去掉后八位得到的**。

## MD5的应用

- 一致性检验
  见最上面那个例子

- 数字证书
  和前面的例子一样，在发行软件的时候，附带一个MD5证书。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。

- 安全认证
  MD5还广泛用于操作系统的登陆认证上，如Unix、各类BSD系统登录密码、数字签名等诸多方面。如在UNⅨ系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。如果用户丢失了密码，只能让管理员重置密码。

关于这一块，我打算专门拿出时间来进行研究下，待更新...

## MD5的缺陷

虽然MD5是不可逆的算法，但是真的有MD5的破解算法！也称为`碰撞算法`。本质就是对于一个给定的MD5，在很短的时间内就能找到可能的源文件内容。前面提到MD5算法是不可逆的，**也就是说破解算法不能保证得到的一定是源文件内容，但是能保证该文件内容计算出的MD5值一定和源文件产生的MD5相同**。我们来看看这有什么危害：比如用户的登录密码为666666，后台数据库存储的是MD5值，假如是0ca175b9c0f726a831d895e269332461。破解的人拿到这个MD5值，使用破解算法计算出和这个MD5碰撞的密码，假如是678865。
这样破解的人就可以使用678865去登录，由于MD5的输出还是0ca175b9c0f726a831d895e269332461，因此这个人就可以顺利登录。
对于这个问题，一个很容易的解决方案是，将用户输入的初始密码复制一份，变成666666666666，然后产生MD5，存入数据库。这样破解算法得到的可能的密码就不再是678865了，他也无法用这个可能密码去登录。
除了碰撞算法破解以外，现在被黑客使用最多的一种破译密码的方法就是一种被称为`"跑字典"`的暴力破解方法(brute force)。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26+26+10=62个字符，排列组合出的字典的项数则是P（62,1）+P（62,2）….+P（62,8），那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5值的情况下才可以。
最后补充下，这种加密技术被广泛的应用于UNIX系统中，这也是为什么UNIX系统比一般操作系统更为坚固一个重要原因。

## Java中的实现

注释已经写的很详细了！

```java
/**
* 数据加密功能实现
* 
* @param data 要加密的数据
* @param mode 加密模式：其实不仅仅支持MD5，比如还支持SHA
* @return 加密后的数据
* @throws Exception 抛出异常
*/
public static String encrypt(byte[] data, String mode) throws Exception {
  //进行实例化.初始化
  MessageDigest md5 = MessageDigest.getInstance(mode);
  //处理数据
  md5.update(data);
  //完成哈希计算返回结果，MessageDigest 对象被重新设置成其初始状态。
  byte[] digest = md5.digest();
  StringBuffer stringBuffer = new StringBuffer();
  //MD5二进制转十六进制，&0xff其实就是取的低八位，
  //注意:int是占4byte的，学过进制换算的都造4"位"二进制相当于1"位"16进制(用词不太当，就那意思)
  for (int i = 0; i < digest.length; i++) {
    int val = ((int) digest[i]) & 0xff;
    if (val < 16) {
      stringBuffer.append("0");
    }
    stringBuffer.append(Integer.toHexString(val);
  }
  return stringBuffer.toString();
}
```

## 后记

以上是MD5的基本概念，如果你想了解MD5的具体算法....
那么我强烈支持你，学会了回来给我讲讲好伐？！
准备更新一大批加密/解密算法相关的基础知识，大佬不教那就自己动手....

> 本文采集自
> http://blog.csdn.net/shuangshuang37278752/article/details/8795000
> http://www.weixuehao.com/archives/474
>
>
> 有删改