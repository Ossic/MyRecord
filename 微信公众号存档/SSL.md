## 基本概念

引用wiki上的一段：

>   传输层安全协议（英语：Transport Layer Security，缩写：**TLS**），及其**前身**安全套接层（Secure Sockets Layer，缩写：**SSL**）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，**推出HTTPS协议，以SSL进行加密，这是SSL的起源。**
>   IETF将SSL进行标准化，1999年公布了第一版**TLS**标准文件。随后又公布了 RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。**在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。**主要的网站，如Google、Facebook等也以这个协议来创建安全连接，发送数据。目前已成为互联网上保密通讯的工业标准。
>
>   SSL包含记录层（Record Layer）和传输层，记录层协议确定了传输层数据的封装格式。传输层安全协议使用X.509认证，之后**利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）**。这个会谈密钥是**用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，**使客户与服务器应用之间的通信不被攻击者窃听。

至于他们的关系，看重点：
TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，**它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1**，它是写入了 RFC 的。从技术上讲，TLS 1.0与SSL 3.0的差异非常微小。

## SSL/TLS概览

SSL是一个介于HTTP协议与TCP之间的一个可选层，其位置大致如下:



SSL/TLS协议提供的服务主要有：

-   认证用户和服务器，确保数据发送到正确的客户机和服务器；
-   加密数据以防止数据中途被窃取；
-   维护数据的完整性，确保数据在传输过程中不被改变。

## 基本的运行过程

SSL/TLS协议的基本思路是**采用公钥加密法**，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题。

1. **如何保证公钥不被篡改？**

   解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

2. **公钥加密计算量太大，如何减少耗用的时间？**
   解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

因此，SSL/TLS协议的基本过程是这样的：

-   客户端向服务器端索要并验证公钥。
-   双方协商生成"对话密钥"。
-   双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

## TLS与SSL的差异

1.  版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。
2.  报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法。SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。
3.  伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式。
4.  报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。
5.  密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。
6.  certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。
7.  加密计算：TLS与SSLv3.0在计算主密值（master secret）时采用的方式不同。
8.  填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。

**TLS的主要增强内容**

TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：

1.  更安全的MAC算法
2.  更严密的警报
3.  “灰色区域”规范的更明确的定义

**TLS对于安全性的改进**

1.  对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。
2.  增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。
3.  改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。
4.  一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。
5.  特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。

## 总结

SSL客户端（也是TCP的客户端）在TCP链接建立之后，发出一个ClientHello来发起握手，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个ServerHello，这里面确定了这次通信所需要的算法，然后发过去自己的证书（里面包含了身份和自己的公钥）。Client在收到这个消息后会生成一个秘密消息，用SSL服务器的公钥加密后传过去，SSL服务器端用自己的私钥解密后，会话密钥协商成功，双方可以用同一份会话密钥来通信了。

是不是感觉和XX有点相似呢....
**插一句SSH主要为计算机上的Shell（壳层）提供安全的传输和使用环境。**

## 引用

关于SSL/TLS详细的解析看下面吧
https://segmentfault.com/a/1190000002554673
http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html