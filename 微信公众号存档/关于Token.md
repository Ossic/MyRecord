>   我早就有这样的疑问，应用或者网站都需要从服务器获取数据，那么是如何保证请求者是合法的呢？
>   最先让我想到的就是各种API接口
>   ~~请证明，你就是你 o(￣▽￣*)ゞ))￣▽￣*)o~~

## 关于Token

很多人翻译为令牌，我感觉还是很形象的，还及得各大银行发的令牌么，道理也差不多

我认为，令牌嘛，不管你用什么算法，一般情况下，只要保证唯一性和时效性即可

## 基于 Token 的身份验证方法

使用基于 Token 的身份验证方法，在**服务端**不需要存储用户的登录记录。大概的流程是这样的：

1.  客户端使用用户名跟密码请求登录
2.  服务端收到请求，去验证用户名与密码
3.  验证成功后，服务端会签发一个 Token(注意这里，可以是每次登陆签发一个新的，也可以设置Token的有效期)，再把这个 Token 发送给客户端
4.  客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
5.  客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6.  服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
    若无效，分两种情况：
    -   token错误，这时需要用户重新登录，获取正确的token
    -   token过期，这时客户端需要再发起一次认证请求，获取新的token

这个token必须要在每次请求时传递给服务端，它应该保存在请求头里

## 拓展之JWT

>   Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（[(RFC 7519](https://tools.ietf.org/html/rfc7519)).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

### JWT什么样

**中间用点分隔开**，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
```

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).

header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法

```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。

JWT 的最后一部分是 Signature ，首先需要Base64 编码的 header`.`payload 作为原料，再用加密算法将其加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。

于是最后的Token就是header`.`payload`.`Signature ；前两部分是Base64编码的，最后一部分是加密后的前两部分

## API接口安全设计

接口的安全性主要围绕Token、Timestamp和Sign三个机制展开设计，保证接口的数据不会被篡改和重复调用。
关于Token我们已经说了，然后是Timestamp和Sign

>   **时间戳超时机制**：用户每次请求都带上当前时间的时间戳timestamp，服务端接收到timestamp后跟当前时间进行比对，如果时间差大于一定时间（比如5分钟），则认为该请求失效，这个时间要保证足够完成本次请求的同时尽量短，可以减少缓存服务器的压力（见签名机制）。
>
>   **签名机制**：将Token和时间戳加上其他请求参数就行MD5或SHA-1算法（可根据情况加点盐）加密，加密后的数据为本次请求的签名sign，并将该签名存放到缓存服务器中，超时时间设定为跟时间戳的超时时间一致（*这就是为什么要尽量短，二者时间一致可以保证无论在timestamp规定时间内还是外本URL都只能访问一次*）。服务端接收到请求后以同样的算法得到签名，并跟当前的签名进行比对，如果不一样，说明参数被更改过，直接返回错误标识。同一个签名只能使用一次，如果发现缓存服务器中已经存在了本次签名，则拒绝服务。

整个流程如下：

>   1、客户端通过用户名密码登录服务器并获取Token
>
>   2、客户端生成时间戳timestamp，并将timestamp作为其中一个参数
>
>   3、客户端将所有的参数，包括Token和timestamp按照自己的算法进行排序加密得到签名sign
>
>   4、将token、timestamp和sign作为请求时必须携带的参数加在每个请求的URL后边（http://url/request?token=123&timestamp=123&sign=123123123）
>
>   5、服务端写一个过滤器对token、timestamp和sign进行验证，只有三个参数都正确且在规定时间内，本次请求才有效

在以上三中机制的保护下，如果黑客劫持了请求，并对请求中的参数进行了修改，签名就无法通过；
如果黑客使用已经劫持的URL进行DOS攻击，服务器则会因为缓存服务器中已经存在签名而拒绝服务，所以DOS攻击也是不可能的；
如果黑客隔一段时间进行一次DOS攻击（假如这个时间大于签名在缓存服务器中的缓存时长），则会因为时间戳超时而无法完成请求，这就是为什么签名的缓存时长要跟时间戳的超时时长一样。

如果签名算法和用户名密码都暴露了....死透了，救不了

关于这个我还有很多想法，以后再议吧！

## 参考

https://ninghao.net/blog/2834
http://www.jianshu.com/p/c6518a8f4040