# 关于同步、异步、并行、并发等

今天就来理一理他们之间的区别与联系，涉及同步与异步、并发与并行、阻塞与非阻塞，以及他们之间的一些联系。

## 同步与异步

同步:多个任务情况下，一个任务A执行结束，才可以执行另一个任务B。（一般只存在一个线程）

异步:多个任务情况下，一个任务A正在执行，同时可以执行另一个任务B。任务B不用等待任务A结束才执行。（多线程是实现异步之一）

异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，**被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。**

异步和同步是**从任务被执行的顺序上来区分的**，从这个基本概念出发，异步并不见得比同步性能高，也就是说异步模型不见得会比同步模型有优势。

异步通常给人一个错觉，就是他比同步快。这里其实是有一个误区，因为一个任务实际被处理的时间并没有太大变化，**只有在带阻塞的任务中，异步才可能比同步快**，因为异步快在将同步模式下带阻塞任务执行过程中cpu的等待时间利用起来处理其他任务，借此提升了多任务系统的整体并发能力。

这里说明一下，在 JavaScript 中都知道 ajax 是异步的，但是 js 的执行是单线程的，实现原理是浏览器开辟一个常驻线程来监听事件的触发，还有另一个常驻线程负责 js 的执行（有的浏览器所有标签页都是一个 js 线程来处理，当一个 fun 卡的时候其他标签页的 js 也会停止运行）。

所以单线程实现异步是有点困难的。

## 并发与并行

~~并发和并行其实是异步线程实现的两种形式~~

并行和并发是站在两个不同角度上理解产生的概念。

### 并发

并发是一个伪异步。在单核 CUP 中同一时刻只能有一条线程运行，但是又想执行多个**任务**。这个时候，只能不停的切换任务，由于CUP处理速度快，你看起来好像是同时执行，其实不是的，同一时间只会执行单个任务。

在操作系统中，并发是指**一个时间段**中有**几个程序（任务）**都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥

互斥：进程间相互排斥的使用**临界资源**的现象，就叫互斥，因为一个简单的语句 cpu 会拆分成多个步骤（比如：取指），所以处理多个任务时需要处理相同的资源必然会有冲突。

同步：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，类似管道，当第一个进程没有输出时第二个进程必须等待。

具有同步关系的一组并发进程相互发送的信息称为消息或事件。

**其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。**

### 并行

**并行**其实是真正的异步，多核CUP可以同时开启多条线程供多个任务同时执行，互不干扰。

在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特征，在逻辑层面上的同时工作。

在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。

从而可知，**并行是针对多处理器而言的**。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。

也就是说：**并行一定是并发，并发却不一定是并行。**

### 其他

那么串行是什么呢，它是同步线程的实现方式，就是任务A执行结束才能开始执行B，单个线程只能执行一个任务，就如单行道只能行驶一辆车。

### 对比

- 并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。**前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．**
- 并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，**并发事件之间不一定要同一时刻发生。**
- 并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。

**并发的关键是你有处理多个任务的能力，不一定要同时。**

**并行的关键是你有同时处理多个任务的能力。**

有张图我认为可以帮助理解：

![](../img/并行.png)

图上反映了一个包含 8 个操作的任务在一个有两核心的 CPU 中创建四个线程运行的情况。

假设每个核心有两个线程，那么**每个CPU中两个线程会交替并发（交替执行），两个CPU之间的操作会并行运算（同时执行）**。

单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，但其本身运行效率并没有提高，多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。

## 阻塞与非阻塞

阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（使cpu进入等待状态）。函数只有在得到结果之后才会返回。

非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**

### 拓展

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞。

阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回。

他们之间是可以进行组合的，详情 http://www.cnblogs.com/tracylining/p/3506673.html

## 多线程

多线程是程序设计的**逻辑层概念**，它是**进程中**并发运行的一段代码。多线程可以实现线程间的切换执行。

并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。

异步和多线程并不是一个同等关系，**异步是最终目的**，**多线程只是我们实现异步的一种手段**。

异步是当一个调用请求发送给被调用者，而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。

特别的一点是, "多线程/多进程"并不代表一定不会"阻塞"(这个可以看一下apache下和php-fpm的线程安全/非线程安全模式), 而实现"非阻塞"也并不一定需要"多线程/多进程"(比如node.js就是单进程/线程且异步非阻塞).